Key Design Decisions
--------------------
[X] Single Responsibility Principle / Separation of Concerns
    [X] Package level segregation for stronger cohesion
    [X] Single Reason to change
        [X] REST Service: User (Actor) focused exposed services
        [x] Command and Query Segregation
[X] Open Close Principle
[X] Liskov Substitution Principle
    [X] validated parent & child relationship - made class abstract where it should not live alone
[X] Interface Segregation
    [X] Segregated client facing interfaces per Actor - avoided god interface
[X] Dependency Inversion
    [X] Objects are wired with Dependency Injection
    [X] Layers are connected via abstraction/ not concrete

Core OO
--------
[] Encapsulation
[] Abstraction
[] Inheritance
[] Polymorphism

Defensive Coding
----------------
[X] Validation at Inputs
    [X] React Early or Validate when creating itself
[X] Valid return values
    [X] not null
[X] Exception Handling
    [X] meaningful exception
[X] Potential Race Condition - sync blocked is used

Performance Tuning
------------------
[X] Datatype: ArrayList & HashMap - Optimal Use
[X] Optimize Concurrent Code
    [X] Reduce contention if possible - lock on the book object rather than the service call itself
[X] Memory Datatype - choose based on data range

What Next:
----------
-> Service will be fetching data from repository
-> As the application grow or if we foresee aggressively growing business
    - let's use bounded context to create microservices
    - multiple independently deployable code
-> System design
    -> Scalability
    -> Availability
    -> Reliability
    -> Efficiency - Latency , Throughput
    -> Telemetry
